---
title: G1 é‚£äº›äº‹å„¿
date: 2018-03-17 15:16:51
tags:
- jvm
- gc
---

# key word

G1, RSets, CSets
**for Hotspot JVM**

--- 

# ç®€å•è¯´è¯´G1æ˜¯ä»€ä¹ˆï¼Ÿ

## G1ç›®æ ‡

- å‡å°‘fullgc

## ä¸ºä»€ä¹ˆå«åšgarbage first

> G1çš„åŸºç¡€æ˜¯regionï¼Œåœ¨æ‰§è¡Œgcæ—¶ï¼ŒG1é¦–å…ˆæ‰¾å‡ºé‚£äº›regionå‡ ä¹æ˜¯ç©ºçš„ï¼Œä¼˜å…ˆå›æ”¶ï¼›å› æ­¤ç§°ä¸º Garbage First

## æœ‰ä»€ä¹ˆä¸åŒ(å¯¹æ¯”Serial,Parallel,CMS)

Serial,Parallel,CMS|G1
---|---
å †ç©ºé—´æ˜¯è¿ç»­çš„ï¼Œåˆ†ä¸ºæ–°ç”Ÿä»£ï¼Œsurvivorå’Œè€å¹´ä»£| regionæ¦‚å¿µï¼Œæ¯ä¸ªregionæ˜¯2çš„å¹‚æ¬¡æ–¹ï¼ˆ2-32MBï¼‰ï¼Œå¹³å‡2000ä¸ªregion
å„ä»£æ˜¯è¿ç»­çš„| å¯¹è±¡å†™å…¥regionï¼Œregionå¯èƒ½å±äºæ–°ç”Ÿä»£ï¼Œä¹Ÿå¯èƒ½å±äºè€å¹´ä»£
å„ä»£å¤§å°å›ºå®š|åŠ¨æ€å†³å®šå“ªäº›regionå±äºæ–°ç”Ÿä»£ã€å“ªäº›å±äºè€å¹´ä»£
æ¯æ¬¡å¤„ç†ä¸€ä¸ªåˆ†ä»£|æ¯æ¬¡å¤„ç†è‹¥å¹²ä¸ªregionï¼Œä¸”ä¸å½±å“å…¶ä½™region

## ç›¸å…³çš„command

This is the complete list of G1 GC switches. Remember to use the best practices outlined above.

Option and Default Value             | Description                                                    
------------------------------------ | ----
-XX:+UseG1GC                         | Use the Garbage First (G1) Collector
-XX:MaxGCPauseMillis=n               | Sets a target for the maximum GC pause time. This is a soft goal, and the JVM will make its best effort to achieve it.
-XX:InitiatingHeapOccupancyPercent=n | Percentage of the (entire) heap occupancy to start a concurrent GC cycle. It is used by GCs that trigger a concurrent GC cycle based on the occupancy of the entire heap, not just one of the generations (e.g., G1). A value of 0 denotes 'do constant GC cycles'. The default value is 45.
-XX:NewRatio=n                       | Ratio of new/old generation sizes. The default value is 2.
-XX:SurvivorRatio=n                  | Ratio of eden/survivor space size. The default value is 8.
-XX:MaxTenuringThreshold=n           | Maximum value for tenuring threshold. The default value is 15. 
-XX:ParallelGCThreads=n              | Sets the number of threads used during parallel phases of the garbage collectors. The default value varies with the platform on which the JVM is running.
-XX:ConcGCThreads=n                  | Number of threads concurrent garbage collectors will use. The default value varies with the platform on which the JVM is running.
-XX:G1ReservePercent=n               | Sets the amount of heap that is reserved as a false ceiling to reduce the possibility of promotion failure. The default value is 10.
-XX:G1HeapRegionSize=n               | With G1 the Java heap is subdivided into uniformly sized regions. This sets the size of the individual sub-divisions. The default value of this parameter is determined ergonomically based upon heap size. The minimum value is 1Mb and the maximum value is 32Mb.

## æœ€ä½³å®è·µ Best practices

- ä¸è¦è®¾ç½®æ–°ç”Ÿä»£å¤§å°(Do not set young generation size by -Xmn)
  - G1 will no longer respect the pause time target for collections. So in essence, setting the young generation size disables the pause time goal.
  - G1 is no longer able to expand and contract the young generation space as needed. Since the size is fixed, no changes can be made to the size.
- GCæš‚åœæ—¶é—´ä¸æ˜¯100%èƒ½ä¿è¯çš„(Response Time Metrics)
Instead of using average response time (ART) as a metric to set the XX:MaxGCPauseMillis=<N>, consider setting value that will meet the goal 90% of the time or more. This means 90% of users making a request will not experience a response time higher than the goal. Remember, the pause time is a goal and is not guaranteed to always be met.
- æ™‹å‡å¤±è´¥ä»¥åŠå¦‚ä½•é¿å…(Evacuation Failure)
å¦‚æœGCçš„æ™‹å‡è¿‡ç¨‹ä¸­é‡åˆ°å †åŒºåŸŸæº¢å‡ºï¼ˆä½¿ç”¨-XX:+PrintGCDetailsçœ‹åˆ°to-space overflowï¼‰ï¼Œå¯ä»¥é€šè¿‡ä¸‹é¢å‡ ç§æ–¹å¼é¿å…ï¼š
  - å¢åŠ -XX:G1ReservePercent=nï¼Œç¼ºçœå€¼æ˜¯10ã€‚è¿™å¯ä»¥å¢åŠ å¯ç”¨çš„to-spaceå†…å­˜
  - ä½¿ç”¨-XX:ConcGCThreads=nå¢åŠ æ ‡è®°çº¿ç¨‹æ•°ç›®

# CMS vs G1

CMSï¼šold generation æ˜¯ä¸€ä¸ªè¿ç»­ç©ºé—´ï¼Œåªæœ‰å‘ç”Ÿfull gcæ—¶æ‰ä¼šè¿›è¡Œå‹ç¼©

## çœ‹å›¾è¯´è¯

### CMS å †ç»“æ„ï¼ˆHeap Structureï¼‰

![](http://anocelot-wiki.oss-cn-hangzhou.aliyuncs.com/wiki/jvm-g1/OldHeapStructure.png)

### G1 å †ç»“æ„ï¼ˆHeap Structureï¼‰

![](http://anocelot-wiki.oss-cn-hangzhou.aliyuncs.com/wiki/jvm-g1/G1HeapStructure.png)

## CMS step

**ç¼ºç‚¹**ï¼šä¸æ”¯æŒå‹ç¼©ï¼ˆcompactï¼‰

**ä¸¤æ¬¡stw**ï¼šInitial Mark, Remark

The CMS collector performs the following phases on the old generation of the heap:

Phase                                       | Description
--------------- | -----------
(1) Initial Mark  <font color=#0099ff>**(Stop the World Event)**</font> |         Objects in old generation are â€œmarkedâ€ as reachable including those objects which may be reachable from young generation. Pause times are typically short in duration relative to minor collection pause times.
(2) Concurrent Marking                      |        Traverse the tenured generation object graph for reachable objects concurrently while Java application threads are executing. Starts scanning from marked objects and transitively marks all objects reachable from the roots. The mutators are executing during the concurrent phases 2, 3, and 5 and any objects allocated in the CMS generation during these phases (including promoted objects) are immediately marked as live.
(3) Remark  <font color=#0099ff>**(Stop the World Event)**</font>       |        Finds objects that were missed by the concurrent mark phase due to updates by Java application threads to objects after the concurrent collector had finished tracing that object.
(4) Concurrent Sweep                        |        Collects the objects identified as unreachable during marking phases. The collection of a dead object adds the space for the object to a free list for later allocation. Coalescing of dead objects may occur at this point. Note that live objects are not moved.
(5) Resetting                               | Prepare for next concurrent collection by clearing data structures.

## G1 step

The G1 collector performs the following phases on the old generation of the heap. Note that some phases are part of a young generation collection.

Phase                                                 | Description  
----------------------------------------------------- | -----
(1) Initial Mark  <font color=#0099ff>**(Stop the World Event)**</font>          |         This is a stop the world event. With G1, it is piggybacked on a normal young GC. Mark survivor regions (root regions) which may have references to objects in old generation.
(2) Root Region Scanning                              |        Scan survivor regions for references into the old generation. This happens while the application continues to run. The phase must be completed before a young GC can occur. 
(3) Concurrent Marking                                |        Find live objects over the entire heap. This happens while the application is running. This phase can be interrupted by young generation garbage collections.
(4) Remark  <font color=#0099ff>**(Stop the World Event)**</font>                 |        Completes the marking of live object in the heap. Uses an algorithm called snapshot-at-the-beginning (SATB) which is much faster than what was used in the CMS collector. 
(5) Cleanup  <font color=#0099ff>**(Stop the World Event and Concurrent)**</font> | 1 Performs accounting on live objects and completely free regions. (Stop the world) 2 Scrubs the Remembered Sets. (Stop the world) 3 Reset the empty regions and return them to the free list. (Concurrent)
(*) Copying  <font color=#0099ff>**(Stop the World Event)**</font>                | These are the stop the world pauses to evacuate or copy live objects to new unused regions. This can be done with young generation regions which are logged as `[GC pause (young)]`. Or both young and old generation regions which are logged as `[GC Pause (mixed)]`

---

ref [Oracle Getting Started with the G1 Garbage Collector](http://www.oracle.com/technetwork/tutorials/tutorials-1876574.html)

# The G1 Garbage Collector

> 1. ç”¨äºæ›¿ä»£CMS
2. å‹ç¼©ç©ºä½™ç©ºé—´æ—¶å¿…æ»¡å»¶é•¿ä¸­æ–­æ—¶é—´
3. æ— éœ€ç‰ºç‰²ååé‡

The Garbage-First (G1) collector is a server-style garbage collector, targeted for multi-processor machines with large memories. It meets garbage collection (GC) pause time goals with a high probability, while achieving high throughput. _The G1 garbage collector is fully supported in Oracle JDK 7 update 4 and later releases_. The G1 collector is designed for applications that:

* Can operate concurrently with applications threads like the CMS collector.
* Compact free space without lengthy GC induced pause times.
* Need more predictable GC pause durations.
* Do not want to sacrifice a lot of throughput performance.
* Do not require a much larger Java heap.

G1 is planned as the long term replacement for the Concurrent Mark-Sweep Collector (CMS). Comparing G1 with CMS, there are differences that make G1 a better solution. One difference is that G1 is a compacting collector. G1 compacts sufficiently to completely avoid the use of fine-grained free lists for allocation, and instead relies on regions. This considerably simplifies parts of the collector, and mostly eliminates potential fragmentation issues. Also, G1 offers more predictable garbage collection pauses than the CMS collector, and allows users to specify desired pause targets.

# G1 vs Serial,Parallel,CMS

Serial,Parallel,CMS| G1
---|---
all structure the heap into three sections: young generation, old generation, and permanent generation of a fixed memory size|partitioned into a set of equal-sized heap regions, each a contiguous range of virtual memory. Certain region sets are assigned the same roles (eden, survivor, old) as in the older collectors, but there is not a fixed size for them
å›ºå®šå¤§å°çš„ä¸‰ä¸ªåˆ†åŒº|åˆ†ä¸ºä¸€ç»„ç›¸åŒå¤§å°çš„regionï¼Œregionç”¨äºç»„æˆåˆ†ä»£edenã€survisorã€oldï¼Œæ¯ä¸ªåˆ†ä»£æ²¡æœ‰å›ºå®šçš„å¤§å°

> - ç”¨æˆ·æŒ‡å®šä¸­æ–­æ—¶é—´(pause time)
- G1åœ¨æŒ‡å®šæ—¶é—´å†…ï¼Œæ ‡è®°å¹¶ä¼˜å…ˆå›æ”¶å­˜æ´»æ•°æ®ï¼ˆliveness objectï¼‰è¾ƒå°‘çš„region
- G1ä¼šå°†å‡ ä¸ªregionä¸­å¹¸å­˜çš„æ•°æ®åˆå¹¶æ‹·è´åˆ°ä¸€ä¸ªregionï¼Œè¾¾åˆ°é‡Šæ”¾regionçš„ç›®çš„
- G1 is not a real-time collectorï¼ˆå¤§æ¦‚å§ğŸ™‚ åœ¨æŒ‡å®šçš„æ—¶é—´å†…ï¼Œèƒ½æ”¶é›†å¤šå°‘æ˜¯å¤šå°‘ï¼‰

GCå¯¹æ¯”
> - CMSï¼šä¸è¿›è¡Œå‹ç¼©ï¼ˆcompactï¼‰
- ParallelOldï¼šåªèƒ½è¿›è¡Œå…¨å †å‹ç¼©ï¼ˆwhile-heap compactionï¼‰ï¼Œä¼šå¯¼è‡´ä¸­æ–­æ—¶é—´å˜é•¿

When performing garbage collections, G1 operates in a manner similar to the CMS collector. G1 performs a concurrent global marking phase to determine the liveness of objects throughout the heap. After the mark phase completes, G1 knows which regions are mostly empty. It collects in these regions first, which usually yields a large amount of free space. This is why this method of garbage collection is called Garbage-First. As the name suggests, G1 concentrates its collection and compaction activity on the areas of the heap that are likely to be full of reclaimable objects, that is, garbage. G1 uses a pause prediction model to meet a user-defined pause time target and selects the number of regions to collect based on the specified pause time target.

The regions identified by G1 as ripe for reclamation are garbage collected using evacuation. G1 copies objects from one or more regions of the heap to a single region on the heap, and in the process both compacts and frees up memory. This evacuation is performed in parallel on multi-processors, to decrease pause times and increase throughput. Thus, with each garbage collection, G1 continuously works to reduce fragmentation, working within the user defined pause times. This is beyond the capability of both the previous methods. CMS (Concurrent Mark Sweep ) garbage collector does not do compaction. ParallelOld garbage collection performs only whole-heap compaction, which results in considerable pause times.

It is important to note that G1 is not a real-time collector. It meets the set pause time target with high probability but not absolute certainty. Based on data from previous collections, G1 does an estimate of how many regions can be collected within the user specified target time. Thus, the collector has a reasonably accurate model of the cost of collecting the regions, and it uses this model to determine which and how many regions to collect while staying within the pause time target.

Note: G1 has both concurrent (runs along with application threads, e.g., refinement, marking, cleanup) and parallel (multi-threaded, e.g., stop the world) phases. Full garbage collections are still single threaded, but if tuned properly your applications should avoid full GCs.

# G1 Footprintï¼ˆğŸ™‚ è¿™ä¸ªæ˜¯å ç”¨ç©ºé—´çš„æ„æ€å§ï¼‰

> ç›¸æ¯”CMSæˆ–ParallelOldGCï¼ŒG1çš„è¿›ç¨‹ï¼ˆJVM process sizeï¼‰ä¼šå¤§äº›ã€‚å› ä¸ºéœ€è¦å­˜å‚¨è®°å½•regionä¿¡æ¯çš„`RSets`å’Œ`CSets`

> - **RSets**: æ¯ä¸ªregionä¸€ä¸ªï¼Œè®°å½•regionä¸­çš„å¯¹è±¡å¼•ç”¨ï¼ˆobject referenceï¼‰
å†…å­˜å ç”¨å°äº5%ï¼›
- **CSets**: è®°å½•å°†è¢«å›æ”¶çš„regionï¼ˆwill be collected in a GCï¼‰
å†…å­˜å ç”¨å°äº1%ï¼›

If you migrate from the ParallelOldGC or CMS collector to G1, you will likely see a larger JVM process size. This is largely related to "accounting" data structures such as Remembered Sets and Collection Sets. 

**Remembered Sets** or RSets track object references into a given region. There is one RSet per region in the heap. The RSet enables the parallel and independent collection of a region. The overall footprint impact of RSets is less than 5%.

**Collection Sets** or CSets the set of regions that will be collected in a GC. All live data in a CSet is evacuated (copied/moved) during a GC. Sets of regions can be Eden, survivor, and/or old generation. CSets have a less than 1% impact on the size of the JVM.

# å“ªäº›æƒ…å†µï¼Œæˆ‘ä»¬é€‚åˆæ¢åˆ°G1

> å¦‚æœé‡åˆ°è¿™äº›æƒ…å†µï¼Œæˆ‘ä»¬å¯ä»¥è€ƒè™‘è¿ç§»åˆ°GC
- full gc è€—æ—¶è¿‡é•¿æˆ–å¤ªé¢‘ç¹
- å¯¹è±¡åˆ†é…çš„é€Ÿåº¦å·®è·è¾ƒå¤§
- ä¸å¸Œæœ›GCæš‚åœæ—¶é—´è¶…è¿‡0.5-1ç§’

The first focus of G1 is to provide a solution for users running applications that require large heaps with limited GC latency. This means heap sizes of around 6GB or larger, and stable and predictable pause time below 0.5 seconds.

Applications running today with either the CMS or the ParallelOldGC garbage collector would benefit switching to G1 if the application has one or more of the following traits.

* Full GC durations are too long or too frequent.
* The rate of object allocation rate or promotion varies significantly.
* Undesired long garbage collection or compaction pauses (longer than 0.5 to 1 second)

**Note:** If you are using CMS or ParallelOldGC and your application is not experiencing long garbage collection pauses, it is fine to stay with your current collector. Changing to the G1 collector is not a requirement for using the latest JDK.
                                                                   