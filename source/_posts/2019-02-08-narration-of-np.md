---
title: NP问题那些事儿
date: 2019-02-08 15:56:48
tags:
- np
---
`P`olynominal（多项式）类问题
`N`ondeterministic `P`olynominal（非确定性多项式）类问题
NP问题、NPC问题、NPH问题

<!-- more --> 

# 何去何从
## 多项式时间 和 非多项式时间
多项式时间：`O(1)`、`O(log(n))`、`O(n^a)`（对于规模为n的输入，在最坏情况下的运行时间是 O(n^k)，其中k为某一确定常数）
非多项式时间：`O(a^n)`、`O(n!)`
后者比前者复杂许多；
时间复杂度排个队：`o(1) < o(n) < o(lgn) < o(n^2) < o(n^a) < o(e^n)（a>2,n表示输入的数据个数，o(1)为常数级别）`

## 我们为什么关心P
我们认为在多项式时间内可解的问题是易处理的问题，在超多项式时间内解决的问题是不易处理的问题；

# 多项式时间的那些事儿

## `P`类问题
`P`olynominal Time 多项式时间`O(n^k)`内可以解决的问题
> 能够在多项式时间内解决的决策问题（可以找到一个能在多项式的时间里解决它的算法）

如 图搜索问题、最短路径问题、最小生成树问题······

## `NP`类问题
`N`ondeterministic `P`olynomial Time 非确定性多项式时间
> **在多项式时间内可以被证明；**
> 不能在多项式时间内解决或不确定能不能在多项式时间内解决，但能在多项式时间验证的问题。

**验证**： 给定一个问题的实例、证书（类似于证据），需要验证这个证书是这个问题的正确答案。

如 **汉密尔顿路径**，实例为G=(V,E)，证书为顶点序列 {v0,v1,v2,v3,….,vk}，我们的目的是要验证这个证书就是这个问题的答案，验证方法为：先遍历一遍这个点序列，看看是不是每个点只出现一次，然后对于(vi,vi+1)是否为G的边，这样就能够验证这个点序列是不是汉密尔顿路径，很显然这个验证过程是多项式时间的，所以汉密尔顿路径是NP问题。

{% note warning %} 注意：NP问题不是非P类问题，此处不要理解错误 {% endnote %}

## `NPC`类问题
`N`on-deterministic `P`olynomial-time `C`omplete Decision Problem
> if any NP-complete problem can be solved in polynomial time, then every problem in NP has a polynomial-time algorithm.

NPC问题的状态是未知的；迄今为止，既没有人找出求解NPC的多项式时间算法，也没有人能够证明对这类不存在多项式时间算法；（也就是 P ≠ NP 问题）

### 证明一个问题是NPC问题
1. 判定问题与最优化问题
最优化问题（Optimization Problem）：每一个可行的解都有一个关联的值，希望找出一个具有最佳值的可行解；
判定问题（Decision Problem）：答案是1或0；
2. 

### 几个诱人的NPC问题
有几个NPC问题非常诱人，因为它们表面上看起来和我们一直的可以用多项式时间算法解决的问题很相似。
下面列出的每一个问题中，一个是可以用多项式时间算法解决的，另一个却是NPC问题；
#### 最短和最长简单路径
最短路径（P）：在有向图G=(V,E)中，在O(VE)时间内从单一源顶点开始找到最短路径；
最长简单路径 -> 确定是否一个图在给定数量的边中包含一条简单路径（NPC）
# 其他

## Halting Problem 图灵停机问题
> 对于某程序P，给出某输入I，求解此程序P是否会到达终止状态。

证明
证明就是构造反例即可：如果存在一个判断停机问题的程序H（H需要的输入是一个程序），我们再构造一个新的程序K，这个程序调用H但是与H的输出正好相反：如果K的输入经H判断为停机，则K不停机；如果K的输入经H判断为不停机，则K停机。现在矛盾出现了：如果我们把K输入K（即用H判断对于程序K，给出输入为K），那么K停机么？如果按逻辑推演，答案应该是：如果K不停机则K停机；如果K停机则K不停机。矛盾出现了。唯一解决矛盾的解释是：不存在这样万能的H。
停机问题和说谎者悖论/理发师悖论是一脉相承的，说谎者/理发师悖论归根结底是定义了一个集合S={a|a is not in a}。补上这个漏洞的唯一方法是拒绝集合的自指。同样停机问题也说明了，不存在一个判定一切程序的程序，因为这个程序本身也是程序。
### 换个说法
程序 L： 我能判断所有的程序能否停机。
程序 C： 哥们，我是来找茬的。既然有你这么牛逼的程序，利用你，我能这样玩，给我任何一个程序，要是你判断停了，我就死循环，老子就不停了。
苏格拉底：（对C说）你把你自己给到自己，即 C(C) 会如何？
1. 如果 C(C) 停了，根据 C 的内部逻辑， C 被 L 验证为停不了的。
2. 如果 C(C) 停不了，根据 C 的内部逻辑， C 被 L 验证为能停机。

总之，充满矛盾。
那么，只能推导出假设的前提是错的：根本没有 L 这种能判断所有程序能否停机的程序。