---
title: 树
date: 2018-07-16 22:06:20
tags:
- algorithm
- tree
---

> 二叉查找树(BST，Binary Search Tree)，平衡二叉查找树(AVL)，红黑树(RBT)，B~/B+/B*树(B-tree)
1. 动态结构：相比静态查找结构，在 `插入` 和 `删除` 时代价更低；
2. 查找的时间复杂度大体维持在 `O(log(N))` 数量级上
<!-- more -->

---
# 应用场景

- AVL树：最早的平衡二叉树之一。应用相对其他数据结构比较少。windows对进程地址空间的管理用到了AVL树。
- 红黑树：平衡二叉树，广泛用在C++的STL中。如map和set都是用红黑树实现的
- B/B+树：用在磁盘文件组织 数据索引和数据库索引。
- Trie树(字典树)：用在统计和排序大量字符串，如自动机。

---

# 那些树

## 二叉查找树 BST
Binary Search Tree
相比静态查找结构，插入和删除的代价更低；

1. 查找代价
任何一个数据的查找过程都需要从根结点出发，沿某一个路径朝叶子结点前进。因此查找中数据比较次数与树的形态密切相关。
当树中每个结点左右子树高度大致相同时，树高为 `logN` 。则平均查找长度与 `logN` 成正比，查找的平均时间复杂度在 `O(logN)` 数量级上。
当先后插入的关键字有序时，`BST` 退化成 *单支树结构* 。此时树高`N`。平均查找长度为 `(N+1)/2`，查找的平均时间复杂度在 `O(N)` 数量级上。
2. 插入代价
新结点插入到树的叶子上，完全不需要改变树中原有结点的组织结构。插入一个结点的代价与查找一个不存在的数据的代价完全相同。
3. 删除代价 
删除操作的时间复杂度最大不会超过 `O(logN)`。
当删除一个结点 `P`，首先需要定位到这个结点 `P`，这个过程需要一个查找的代价。
然后稍微改变一下树的形态。
如果被删除结点的左、右子树只有一个存在，则改变形态的代价仅为 `O(1)`。
如果被删除结点的左、右子树均存在，只需要将当P的左孩子的右孩子的右孩子的...的右叶子结点与 `P` 互换，在改变一些左右子树即可。

### BST 效率
1. 查找
最好时间复杂度 `O(logN)`；
最坏时间复杂度 `O(N)`；
2. 插入删除操作算法简单，时间复杂度与查找差不多

--- 

## 平衡二叉查找树 AVL

### 为什么需要AVL
> 由于 `二叉查找树BST` 不够平衡，所以在 `最差` 情况下查找的时间复杂度为 `O(N)`，劣化为顺序查找效率

### 什么是AVL
`AVL` 树是根据它的发明者 G.M. `A`delson-`V`elsky 和 E.M. `L`andis 命名的。
它是最先发明的自平衡二叉查找树，也被称为高度平衡树；

> AVL = BST + `树中任何节点的两个子树的高度最大差别为1`

### 操作
1. 查找代价
AVL是严格平衡的BST（平衡因子不超过1）。那么查找过程与BST一样，只是AVL不会出现最差情况的BST(单支树)。因此查找效率最好，最坏情况都是O(logN)数量级的。
2. 插入代价
AVL必须要保证严格平衡(|bf|=1)，那么每一次插入数据使得AVL中某些结点的平衡因子超过1就必须进行旋转操作。事实上，AVL的每一次插入结点操作最多只需要旋转1次(单旋转或双旋转)。因此，总体上插入操作的代价仍然在O(logN)级别上(插入结点需要首先查找插入的位置)。
3. 删除代价：AVL删除结点的算法可以参见BST的删除结点，但是删除之后必须检查从删除结点开始到根结点路径上的所有结点的平衡因子。因此删除的代价稍微要大一些。每一次删除操作最多需要O(logN)次旋转。因此，删除操作的时间复杂度为O(logN)+O(logN)=O(2logN)

### AVL 效率
查找的时间复杂度维持在O(logN)，不会出现最差情况
AVL树在执行每个插入操作时最多需要1次旋转，其时间复杂度在O(logN)左右。
AVL树在执行删除时代价稍大，执行每个删除操作的时间复杂度需要O(2logN)。

## 红黑树 Red-Black Tree

> 红黑树 = 不那么严格的 AVL



















